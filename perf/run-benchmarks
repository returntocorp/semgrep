#! /usr/bin/env python3
#
# Run semgrep on a series of pairs (rules, repo) with different options,
# and report the time it takes. Optionally upload the results to the semgrep
# dashboard.
#
import argparse
import os
import subprocess
import time
from contextlib import contextmanager
from pathlib import Path
from typing import Iterator
from typing import List

DASHBOARD_URL = "https://dashboard.semgrep.dev"

# Run command and propagate errors
def cmd(*args: str) -> None:
    subprocess.run(args, check=True)  # nosem


class Corpus:
    def __init__(self, name: str, lang: str, rule_dir: str, target_dir: str):
        # name for the input corpus (rules and targets)
        self.name = name

        # language of the targets as understood by semgrep e.g. 'js'
        self.lang = lang

        # folder containing the semgrep rules
        self.rule_dir = rule_dir

        # folder containing the target source files
        self.target_dir = target_dir

    # Fetch rules and targets is delegated to an ad-hoc script named 'prep'.
    def prep(self) -> None:
        cmd("./prep")


CORPUSES = [
    Corpus(
        "njs", "js", "input/njsscan/njsscan/rules/semantic_grep", "input/juice-shop"
    ),
]


class SemgrepVariant:
    def __init__(self, name: str, semgrep_core_extra: str):
        # name for the input corpus (rules and targets)
        self.name = name

        # space-separated extra arguments to pass to the default semgrep
        # command
        self.semgrep_core_extra = semgrep_core_extra


# Feel free to create new variants. The idea is to use the default set
# of options as the baseline and we see what happens when we enable or
# disable this or that optimization.
#
SEMGREP_VARIANTS = [
    SemgrepVariant("std", ""),
    SemgrepVariant("no-cache", "-no_opt_cache"),
    SemgrepVariant("max-cache", "-opt_max_cache"),
    SemgrepVariant("no-bloom", "-no_bloom_filter"),
]

# Add support for: with chdir(DIR): ...
@contextmanager
def chdir(dir: str) -> Iterator[None]:
    old_dir = os.getcwd()
    os.chdir(dir)
    try:
        yield
    finally:
        os.chdir(old_dir)


def upload_result(metric_name: str, value: float) -> None:
    print("TODO: upload to dashboard")


def run_semgrep(semgrep: str, corpus: Corpus, variant: SemgrepVariant) -> float:
    args = semgrep.split()
    args.extend(
        [
            "--lang",
            corpus.lang,
            "--strict",
            "--config",
            corpus.rule_dir,
            corpus.target_dir,
        ]
    )
    print("current directory: {}".format(os.getcwd()))
    print("semgrep command: {}".format(args))
    os.environ["SEMGREP_CORE_EXTRA"] = variant.semgrep_core_extra
    print("extra arguments for semgrep-core: {}".format(variant.semgrep_core_extra))
    t1 = time.time()
    subprocess.run(args, check=True)  # nosem
    t2 = time.time()
    return t2 - t1


def run_benchmarks(semgrep: str, upload: bool) -> None:
    for corpus in CORPUSES:
        with chdir(corpus.name):
            corpus.prep()
            for variant in SEMGREP_VARIANTS:
                name = ".".join(["semgrep", "bench", corpus.name, variant.name])
                metric_name = ".".join([name, "duration"])
                print("------ {} ------".format(name))
                duration = run_semgrep(semgrep, corpus, variant)
                print("{} = {:.3f} s".format(metric_name, duration))
                if upload:
                    upload_result(metric_name, duration)


def main() -> None:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--upload", help="upload results to semgrep dashboard", action="store_true"
    )
    parser.add_argument(
        "--semgrep",
        metavar="CMD",
        type=str,
        default="semgrep",
        help="upload results to semgrep dashboard",
    )
    args = parser.parse_args()
    with chdir("bench"):
        run_benchmarks(args.semgrep, args.upload)


if __name__ == "__main__":
    main()
